"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BskyAgent = void 0;
const syntax_1 = require("@atproto/syntax");
const common_web_1 = require("@atproto/common-web");
const await_lock_1 = __importDefault(require("await-lock"));
const agent_1 = require("./agent");
const client_1 = require("./client");
const labels_1 = require("./moderation/const/labels");
const util_1 = require("./util");
const moderation_1 = require("./moderation");
const FEED_VIEW_PREF_DEFAULTS = {
    hideReplies: false,
    hideRepliesByUnfollowed: true,
    hideRepliesByLikeCount: 0,
    hideReposts: false,
    hideQuotePosts: false,
};
const THREAD_VIEW_PREF_DEFAULTS = {
    sort: 'oldest',
    prioritizeFollowedUsers: true,
};
class BskyAgent extends agent_1.AtpAgent {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_prefsLock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new await_lock_1.default()
        });
        Object.defineProperty(this, "getTimeline", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getTimeline(params, opts)
        });
        Object.defineProperty(this, "getAuthorFeed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getAuthorFeed(params, opts)
        });
        Object.defineProperty(this, "getActorLikes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getActorLikes(params, opts)
        });
        Object.defineProperty(this, "getPostThread", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getPostThread(params, opts)
        });
        Object.defineProperty(this, "getPost", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params) => this.api.app.bsky.feed.post.get(params)
        });
        Object.defineProperty(this, "getPosts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getPosts(params, opts)
        });
        Object.defineProperty(this, "getLikes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getLikes(params, opts)
        });
        Object.defineProperty(this, "getRepostedBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getRepostedBy(params, opts)
        });
        Object.defineProperty(this, "getFollows", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.graph.getFollows(params, opts)
        });
        Object.defineProperty(this, "getFollowers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.graph.getFollowers(params, opts)
        });
        Object.defineProperty(this, "getProfile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.getProfile(params, opts)
        });
        Object.defineProperty(this, "getProfiles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.getProfiles(params, opts)
        });
        Object.defineProperty(this, "getSuggestions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.getSuggestions(params, opts)
        });
        Object.defineProperty(this, "searchActors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.searchActors(params, opts)
        });
        Object.defineProperty(this, "searchActorsTypeahead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.searchActorsTypeahead(params, opts)
        });
        Object.defineProperty(this, "listNotifications", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.notification.listNotifications(params, opts)
        });
        Object.defineProperty(this, "countUnreadNotifications", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.notification.getUnreadCount(params, opts)
        });
        Object.defineProperty(this, "getLabelers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.labeler.getServices(params, opts)
        });
    }
    clone() {
        const inst = new BskyAgent({
            service: this.service,
        });
        this.copyInto(inst);
        return inst;
    }
    get app() {
        return this.api.app;
    }
    async getLabelDefinitions(prefs) {
        // collect the labeler dids
        let dids = BskyAgent.appLabelers;
        if (isBskyPrefs(prefs)) {
            dids = dids.concat(prefs.moderationPrefs.labelers.map((l) => l.did));
        }
        else if (isModPrefs(prefs)) {
            dids = dids.concat(prefs.labelers.map((l) => l.did));
        }
        else {
            dids = dids.concat(prefs);
        }
        // fetch their definitions
        const labelers = await this.getLabelers({
            dids,
            detailed: true,
        });
        // assemble a map of labeler dids to the interpreted label value definitions
        const labelDefs = {};
        if (labelers.data) {
            for (const labeler of labelers.data
                .views) {
                labelDefs[labeler.creator.did] = (0, moderation_1.interpretLabelValueDefinitions)(labeler);
            }
        }
        return labelDefs;
    }
    async post(record) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        record.createdAt = record.createdAt || new Date().toISOString();
        return this.api.app.bsky.feed.post.create({ repo: this.session.did }, record);
    }
    async deletePost(postUri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const postUrip = new syntax_1.AtUri(postUri);
        return await this.api.app.bsky.feed.post.delete({
            repo: postUrip.hostname,
            rkey: postUrip.rkey,
        });
    }
    async like(uri, cid) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        return await this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
            subject: { uri, cid },
            createdAt: new Date().toISOString(),
        });
    }
    async deleteLike(likeUri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const likeUrip = new syntax_1.AtUri(likeUri);
        return await this.api.app.bsky.feed.like.delete({
            repo: likeUrip.hostname,
            rkey: likeUrip.rkey,
        });
    }
    async repost(uri, cid) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        return await this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
            subject: { uri, cid },
            createdAt: new Date().toISOString(),
        });
    }
    async deleteRepost(repostUri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const repostUrip = new syntax_1.AtUri(repostUri);
        return await this.api.app.bsky.feed.repost.delete({
            repo: repostUrip.hostname,
            rkey: repostUrip.rkey,
        });
    }
    async follow(subjectDid) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        return await this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
            subject: subjectDid,
            createdAt: new Date().toISOString(),
        });
    }
    async deleteFollow(followUri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const followUrip = new syntax_1.AtUri(followUri);
        return await this.api.app.bsky.graph.follow.delete({
            repo: followUrip.hostname,
            rkey: followUrip.rkey,
        });
    }
    async upsertProfile(updateFn) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        let retriesRemaining = 5;
        while (retriesRemaining >= 0) {
            // fetch existing
            const existing = await this.com.atproto.repo
                .getRecord({
                repo: this.session.did,
                collection: 'app.bsky.actor.profile',
                rkey: 'self',
            })
                .catch((_) => undefined);
            // run the update
            const updated = await updateFn(existing?.data.value);
            if (updated) {
                updated.$type = 'app.bsky.actor.profile';
            }
            // validate the record
            const validation = client_1.AppBskyActorProfile.validateRecord(updated);
            if (!validation.success) {
                throw validation.error;
            }
            try {
                // attempt the put
                await this.com.atproto.repo.putRecord({
                    repo: this.session.did,
                    collection: 'app.bsky.actor.profile',
                    rkey: 'self',
                    record: updated,
                    swapRecord: existing?.data.cid || null,
                });
            }
            catch (e) {
                if (retriesRemaining > 0 &&
                    e instanceof client_1.ComAtprotoRepoPutRecord.InvalidSwapError) {
                    // try again
                    retriesRemaining--;
                    continue;
                }
                else {
                    throw e;
                }
            }
            break;
        }
    }
    async mute(actor) {
        return this.api.app.bsky.graph.muteActor({ actor });
    }
    async unmute(actor) {
        return this.api.app.bsky.graph.unmuteActor({ actor });
    }
    async muteModList(uri) {
        return this.api.app.bsky.graph.muteActorList({
            list: uri,
        });
    }
    async unmuteModList(uri) {
        return this.api.app.bsky.graph.unmuteActorList({
            list: uri,
        });
    }
    async blockModList(uri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        return await this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
            subject: uri,
            createdAt: new Date().toISOString(),
        });
    }
    async unblockModList(uri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const listInfo = await this.api.app.bsky.graph.getList({
            list: uri,
            limit: 1,
        });
        if (!listInfo.data.list.viewer?.blocked) {
            return;
        }
        const { rkey } = new syntax_1.AtUri(listInfo.data.list.viewer.blocked);
        return await this.api.app.bsky.graph.listblock.delete({
            repo: this.session.did,
            rkey,
        });
    }
    async updateSeenNotifications(seenAt) {
        seenAt = seenAt || new Date().toISOString();
        return this.api.app.bsky.notification.updateSeen({
            seenAt,
        });
    }
    async getPreferences() {
        const prefs = {
            feeds: {
                saved: undefined,
                pinned: undefined,
            },
            // @ts-ignore populating below
            savedFeeds: undefined,
            feedViewPrefs: {
                home: {
                    ...FEED_VIEW_PREF_DEFAULTS,
                },
            },
            threadViewPrefs: { ...THREAD_VIEW_PREF_DEFAULTS },
            moderationPrefs: {
                adultContentEnabled: false,
                labels: { ...labels_1.DEFAULT_LABEL_SETTINGS },
                labelers: BskyAgent.appLabelers.map((did) => ({ did, labels: {} })),
                mutedWords: [],
                hiddenPosts: [],
            },
            birthDate: undefined,
            interests: {
                tags: [],
            },
            bskyAppState: {
                queuedNudges: [],
                activeProgressGuide: undefined,
            },
        };
        const res = await this.app.bsky.actor.getPreferences({});
        const labelPrefs = [];
        for (const pref of res.data.preferences) {
            if (client_1.AppBskyActorDefs.isAdultContentPref(pref) &&
                client_1.AppBskyActorDefs.validateAdultContentPref(pref).success) {
                // adult content preferences
                prefs.moderationPrefs.adultContentEnabled = pref.enabled;
            }
            else if (client_1.AppBskyActorDefs.isContentLabelPref(pref) &&
                client_1.AppBskyActorDefs.validateContentLabelPref(pref).success) {
                // content label preference
                const adjustedPref = adjustLegacyContentLabelPref(pref);
                labelPrefs.push(adjustedPref);
            }
            else if (client_1.AppBskyActorDefs.isLabelersPref(pref) &&
                client_1.AppBskyActorDefs.validateLabelersPref(pref).success) {
                // labelers preferences
                prefs.moderationPrefs.labelers = BskyAgent.appLabelers
                    .map((did) => ({ did, labels: {} }))
                    .concat(pref.labelers.map((labeler) => ({
                    ...labeler,
                    labels: {},
                })));
            }
            else if (client_1.AppBskyActorDefs.isSavedFeedsPrefV2(pref) &&
                client_1.AppBskyActorDefs.validateSavedFeedsPrefV2(pref).success) {
                prefs.savedFeeds = pref.items;
            }
            else if (client_1.AppBskyActorDefs.isSavedFeedsPref(pref) &&
                client_1.AppBskyActorDefs.validateSavedFeedsPref(pref).success) {
                // saved and pinned feeds
                prefs.feeds.saved = pref.saved;
                prefs.feeds.pinned = pref.pinned;
            }
            else if (client_1.AppBskyActorDefs.isPersonalDetailsPref(pref) &&
                client_1.AppBskyActorDefs.validatePersonalDetailsPref(pref).success) {
                // birth date (irl)
                if (pref.birthDate) {
                    prefs.birthDate = new Date(pref.birthDate);
                }
            }
            else if (client_1.AppBskyActorDefs.isFeedViewPref(pref) &&
                client_1.AppBskyActorDefs.validateFeedViewPref(pref).success) {
                // feed view preferences
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, feed, ...v } = pref;
                prefs.feedViewPrefs[pref.feed] = { ...FEED_VIEW_PREF_DEFAULTS, ...v };
            }
            else if (client_1.AppBskyActorDefs.isThreadViewPref(pref) &&
                client_1.AppBskyActorDefs.validateThreadViewPref(pref).success) {
                // thread view preferences
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, ...v } = pref;
                prefs.threadViewPrefs = { ...prefs.threadViewPrefs, ...v };
            }
            else if (client_1.AppBskyActorDefs.isInterestsPref(pref) &&
                client_1.AppBskyActorDefs.validateInterestsPref(pref).success) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, ...v } = pref;
                prefs.interests = { ...prefs.interests, ...v };
            }
            else if (client_1.AppBskyActorDefs.isMutedWordsPref(pref) &&
                client_1.AppBskyActorDefs.validateMutedWordsPref(pref).success) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, ...v } = pref;
                prefs.moderationPrefs.mutedWords = v.items;
                if (prefs.moderationPrefs.mutedWords.length) {
                    prefs.moderationPrefs.mutedWords =
                        prefs.moderationPrefs.mutedWords.map((word) => {
                            word.actorTarget = word.actorTarget || 'all';
                            return word;
                        });
                }
            }
            else if (client_1.AppBskyActorDefs.isHiddenPostsPref(pref) &&
                client_1.AppBskyActorDefs.validateHiddenPostsPref(pref).success) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, ...v } = pref;
                prefs.moderationPrefs.hiddenPosts = v.items;
            }
            else if (client_1.AppBskyActorDefs.isBskyAppStatePref(pref) &&
                client_1.AppBskyActorDefs.validateBskyAppStatePref(pref).success) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, ...v } = pref;
                prefs.bskyAppState.queuedNudges = v.queuedNudges || [];
                prefs.bskyAppState.activeProgressGuide = v.activeProgressGuide;
            }
        }
        /*
         * If `prefs.savedFeeds` is undefined, no `savedFeedsPrefV2` exists, which
         * means we want to try to migrate if needed.
         *
         * If v1 prefs exist, they will be migrated to v2.
         *
         * If no v1 prefs exist, the user is either new, or could be old and has
         * never edited their feeds.
         */
        if (prefs.savedFeeds === undefined) {
            const { saved, pinned } = prefs.feeds;
            if (saved && pinned) {
                const uniqueMigratedSavedFeeds = new Map();
                // insert Following feed first
                uniqueMigratedSavedFeeds.set('timeline', {
                    id: common_web_1.TID.nextStr(),
                    type: 'timeline',
                    value: 'following',
                    pinned: true,
                });
                // use pinned as source of truth for feed order
                for (const uri of pinned) {
                    const type = (0, util_1.getSavedFeedType)(uri);
                    // only want supported types
                    if (type === 'unknown')
                        continue;
                    uniqueMigratedSavedFeeds.set(uri, {
                        id: common_web_1.TID.nextStr(),
                        type,
                        value: uri,
                        pinned: true,
                    });
                }
                for (const uri of saved) {
                    if (!uniqueMigratedSavedFeeds.has(uri)) {
                        const type = (0, util_1.getSavedFeedType)(uri);
                        // only want supported types
                        if (type === 'unknown')
                            continue;
                        uniqueMigratedSavedFeeds.set(uri, {
                            id: common_web_1.TID.nextStr(),
                            type,
                            value: uri,
                            pinned: false,
                        });
                    }
                }
                prefs.savedFeeds = Array.from(uniqueMigratedSavedFeeds.values());
            }
            else {
                prefs.savedFeeds = [
                    {
                        id: common_web_1.TID.nextStr(),
                        type: 'timeline',
                        value: 'following',
                        pinned: true,
                    },
                ];
            }
            // save to user preferences so this migration doesn't re-occur
            await this.overwriteSavedFeeds(prefs.savedFeeds);
        }
        // apply the label prefs
        for (const pref of labelPrefs) {
            if (pref.labelerDid) {
                const labeler = prefs.moderationPrefs.labelers.find((labeler) => labeler.did === pref.labelerDid);
                if (!labeler)
                    continue;
                labeler.labels[pref.label] = pref.visibility;
            }
            else {
                prefs.moderationPrefs.labels[pref.label] =
                    pref.visibility;
            }
        }
        prefs.moderationPrefs.labels = remapLegacyLabels(prefs.moderationPrefs.labels);
        // automatically configure the client
        this.configureLabelersHeader(prefsArrayToLabelerDids(res.data.preferences));
        return prefs;
    }
    async overwriteSavedFeeds(savedFeeds) {
        savedFeeds.forEach(util_1.validateSavedFeed);
        const uniqueSavedFeeds = new Map();
        savedFeeds.forEach((feed) => {
            // remove and re-insert to preserve order
            if (uniqueSavedFeeds.has(feed.id)) {
                uniqueSavedFeeds.delete(feed.id);
            }
            uniqueSavedFeeds.set(feed.id, feed);
        });
        return updateSavedFeedsV2Preferences(this, () => Array.from(uniqueSavedFeeds.values()));
    }
    async updateSavedFeeds(savedFeedsToUpdate) {
        savedFeedsToUpdate.map(util_1.validateSavedFeed);
        return updateSavedFeedsV2Preferences(this, (savedFeeds) => {
            return savedFeeds.map((savedFeed) => {
                const updatedVersion = savedFeedsToUpdate.find((updated) => savedFeed.id === updated.id);
                if (updatedVersion) {
                    return {
                        ...savedFeed,
                        // only update pinned
                        pinned: updatedVersion.pinned,
                    };
                }
                return savedFeed;
            });
        });
    }
    async addSavedFeeds(savedFeeds) {
        const toSave = savedFeeds.map((f) => ({
            ...f,
            id: common_web_1.TID.nextStr(),
        }));
        toSave.forEach(util_1.validateSavedFeed);
        return updateSavedFeedsV2Preferences(this, (savedFeeds) => [
            ...savedFeeds,
            ...toSave,
        ]);
    }
    async removeSavedFeeds(ids) {
        return updateSavedFeedsV2Preferences(this, (savedFeeds) => [
            ...savedFeeds.filter((feed) => !ids.find((id) => feed.id === id)),
        ]);
    }
    /**
     * @deprecated use `overwriteSavedFeeds`
     */
    async setSavedFeeds(saved, pinned) {
        return updateFeedPreferences(this, () => ({
            saved,
            pinned,
        }));
    }
    /**
     * @deprecated use `addSavedFeeds`
     */
    async addSavedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
            saved: [...saved.filter((uri) => uri !== v), v],
            pinned,
        }));
    }
    /**
     * @deprecated use `removeSavedFeeds`
     */
    async removeSavedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
            saved: saved.filter((uri) => uri !== v),
            pinned: pinned.filter((uri) => uri !== v),
        }));
    }
    /**
     * @deprecated use `addSavedFeeds` or `updateSavedFeeds`
     */
    async addPinnedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
            saved: [...saved.filter((uri) => uri !== v), v],
            pinned: [...pinned.filter((uri) => uri !== v), v],
        }));
    }
    /**
     * @deprecated use `updateSavedFeeds` or `removeSavedFeeds`
     */
    async removePinnedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
            saved,
            pinned: pinned.filter((uri) => uri !== v),
        }));
    }
    async setAdultContentEnabled(v) {
        await updatePreferences(this, (prefs) => {
            let adultContentPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isAdultContentPref(pref) &&
                client_1.AppBskyActorDefs.validateAdultContentPref(pref).success);
            if (adultContentPref) {
                adultContentPref.enabled = v;
            }
            else {
                adultContentPref = {
                    $type: 'app.bsky.actor.defs#adultContentPref',
                    enabled: v,
                };
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isAdultContentPref(pref))
                .concat([adultContentPref]);
        });
    }
    async setContentLabelPref(key, value, labelerDid) {
        if (labelerDid) {
            (0, syntax_1.ensureValidDid)(labelerDid);
        }
        await updatePreferences(this, (prefs) => {
            let labelPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isContentLabelPref(pref) &&
                client_1.AppBskyActorDefs.validateContentLabelPref(pref).success &&
                pref.label === key &&
                pref.labelerDid === labelerDid);
            let legacyLabelPref;
            if (labelPref) {
                labelPref.visibility = value;
            }
            else {
                labelPref = {
                    $type: 'app.bsky.actor.defs#contentLabelPref',
                    label: key,
                    labelerDid,
                    visibility: value,
                };
            }
            if (client_1.AppBskyActorDefs.isContentLabelPref(labelPref)) {
                // is global
                if (!labelPref.labelerDid) {
                    const legacyLabelValue = {
                        'graphic-media': 'gore',
                        porn: 'nsfw',
                        sexual: 'suggestive',
                    }[labelPref.label];
                    // if it's a legacy label, double-write the legacy label
                    if (legacyLabelValue) {
                        legacyLabelPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isContentLabelPref(pref) &&
                            client_1.AppBskyActorDefs.validateContentLabelPref(pref).success &&
                            pref.label === legacyLabelValue &&
                            pref.labelerDid === undefined);
                        if (legacyLabelPref) {
                            legacyLabelPref.visibility = value;
                        }
                        else {
                            legacyLabelPref = {
                                $type: 'app.bsky.actor.defs#contentLabelPref',
                                label: legacyLabelValue,
                                labelerDid: undefined,
                                visibility: value,
                            };
                        }
                    }
                }
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isContentLabelPref(pref) ||
                !(pref.label === key && pref.labelerDid === labelerDid))
                .concat([labelPref])
                .filter((pref) => {
                if (!legacyLabelPref)
                    return true;
                return (!client_1.AppBskyActorDefs.isContentLabelPref(pref) ||
                    !(pref.label === legacyLabelPref.label &&
                        pref.labelerDid === undefined));
            })
                .concat(legacyLabelPref ? [legacyLabelPref] : []);
        });
    }
    async addLabeler(did) {
        const prefs = await updatePreferences(this, (prefs) => {
            let labelersPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isLabelersPref(pref) &&
                client_1.AppBskyActorDefs.validateLabelersPref(pref).success);
            if (!labelersPref) {
                labelersPref = {
                    $type: 'app.bsky.actor.defs#labelersPref',
                    labelers: [],
                };
            }
            if (client_1.AppBskyActorDefs.isLabelersPref(labelersPref)) {
                let labelerPrefItem = labelersPref.labelers.find((labeler) => labeler.did === did);
                if (!labelerPrefItem) {
                    labelerPrefItem = {
                        did,
                    };
                    labelersPref.labelers.push(labelerPrefItem);
                }
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isLabelersPref(pref))
                .concat([labelersPref]);
        });
        // automatically configure the client
        this.configureLabelersHeader(prefsArrayToLabelerDids(prefs));
    }
    async removeLabeler(did) {
        const prefs = await updatePreferences(this, (prefs) => {
            let labelersPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isLabelersPref(pref) &&
                client_1.AppBskyActorDefs.validateLabelersPref(pref).success);
            if (!labelersPref) {
                labelersPref = {
                    $type: 'app.bsky.actor.defs#labelersPref',
                    labelers: [],
                };
            }
            if (client_1.AppBskyActorDefs.isLabelersPref(labelersPref)) {
                labelersPref.labelers = labelersPref.labelers.filter((labeler) => labeler.did !== did);
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isLabelersPref(pref))
                .concat([labelersPref]);
        });
        // automatically configure the client
        this.configureLabelersHeader(prefsArrayToLabelerDids(prefs));
    }
    async setPersonalDetails({ birthDate, }) {
        birthDate = birthDate instanceof Date ? birthDate.toISOString() : birthDate;
        await updatePreferences(this, (prefs) => {
            let personalDetailsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isPersonalDetailsPref(pref) &&
                client_1.AppBskyActorDefs.validatePersonalDetailsPref(pref).success);
            if (personalDetailsPref) {
                personalDetailsPref.birthDate = birthDate;
            }
            else {
                personalDetailsPref = {
                    $type: 'app.bsky.actor.defs#personalDetailsPref',
                    birthDate,
                };
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isPersonalDetailsPref(pref))
                .concat([personalDetailsPref]);
        });
    }
    async setFeedViewPrefs(feed, pref) {
        await updatePreferences(this, (prefs) => {
            const existing = prefs.findLast((pref) => client_1.AppBskyActorDefs.isFeedViewPref(pref) &&
                client_1.AppBskyActorDefs.validateFeedViewPref(pref).success &&
                pref.feed === feed);
            if (existing) {
                pref = { ...existing, ...pref };
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isFeedViewPref(pref) || p.feed !== feed)
                .concat([{ ...pref, $type: 'app.bsky.actor.defs#feedViewPref', feed }]);
        });
    }
    async setThreadViewPrefs(pref) {
        await updatePreferences(this, (prefs) => {
            const existing = prefs.findLast((pref) => client_1.AppBskyActorDefs.isThreadViewPref(pref) &&
                client_1.AppBskyActorDefs.validateThreadViewPref(pref).success);
            if (existing) {
                pref = { ...existing, ...pref };
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isThreadViewPref(p))
                .concat([{ ...pref, $type: 'app.bsky.actor.defs#threadViewPref' }]);
        });
    }
    async setInterestsPref(pref) {
        await updatePreferences(this, (prefs) => {
            const existing = prefs.findLast((pref) => client_1.AppBskyActorDefs.isInterestsPref(pref) &&
                client_1.AppBskyActorDefs.validateInterestsPref(pref).success);
            if (existing) {
                pref = { ...existing, ...pref };
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isInterestsPref(p))
                .concat([{ ...pref, $type: 'app.bsky.actor.defs#interestsPref' }]);
        });
    }
    /**
     * Add a muted word to user preferences.
     */
    async addMutedWord(mutedWord) {
        const sanitizedValue = (0, util_1.sanitizeMutedWordValue)(mutedWord.value);
        if (!sanitizedValue)
            return;
        await updatePreferences(this, (prefs) => {
            let mutedWordsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isMutedWordsPref(pref) &&
                client_1.AppBskyActorDefs.validateMutedWordsPref(pref).success);
            const newMutedWord = {
                id: common_web_1.TID.nextStr(),
                value: sanitizedValue,
                targets: mutedWord.targets || [],
                actorTarget: mutedWord.actorTarget || 'all',
                expiresAt: mutedWord.expiresAt || undefined,
            };
            if (mutedWordsPref && client_1.AppBskyActorDefs.isMutedWordsPref(mutedWordsPref)) {
                mutedWordsPref.items.push(newMutedWord);
                /**
                 * Migrate any old muted words that don't have an id
                 */
                mutedWordsPref.items = migrateLegacyMutedWordsItems(mutedWordsPref.items);
            }
            else {
                // if the pref doesn't exist, create it
                mutedWordsPref = {
                    items: [newMutedWord],
                };
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isMutedWordsPref(p))
                .concat([
                { ...mutedWordsPref, $type: 'app.bsky.actor.defs#mutedWordsPref' },
            ]);
        });
    }
    /**
     * Convenience method to add muted words to user preferences
     */
    async addMutedWords(newMutedWords) {
        await Promise.all(newMutedWords.map((word) => this.addMutedWord(word)));
    }
    /**
     * @deprecated use `addMutedWords` or `addMutedWord` instead
     */
    async upsertMutedWords(mutedWords) {
        await this.addMutedWords(mutedWords);
    }
    /**
     * Update a muted word in user preferences.
     */
    async updateMutedWord(mutedWord) {
        await updatePreferences(this, (prefs) => {
            const mutedWordsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isMutedWordsPref(pref) &&
                client_1.AppBskyActorDefs.validateMutedWordsPref(pref).success);
            if (mutedWordsPref && client_1.AppBskyActorDefs.isMutedWordsPref(mutedWordsPref)) {
                mutedWordsPref.items = mutedWordsPref.items.map((existingItem) => {
                    const match = matchMutedWord(existingItem, mutedWord);
                    if (match) {
                        const updated = {
                            ...existingItem,
                            ...mutedWord,
                        };
                        return {
                            id: existingItem.id || common_web_1.TID.nextStr(),
                            value: (0, util_1.sanitizeMutedWordValue)(updated.value) || existingItem.value,
                            targets: updated.targets || [],
                            actorTarget: updated.actorTarget || 'all',
                            expiresAt: updated.expiresAt || undefined,
                        };
                    }
                    else {
                        return existingItem;
                    }
                });
                /**
                 * Migrate any old muted words that don't have an id
                 */
                mutedWordsPref.items = migrateLegacyMutedWordsItems(mutedWordsPref.items);
                return prefs
                    .filter((p) => !client_1.AppBskyActorDefs.isMutedWordsPref(p))
                    .concat([
                    { ...mutedWordsPref, $type: 'app.bsky.actor.defs#mutedWordsPref' },
                ]);
            }
            return prefs;
        });
    }
    /**
     * Remove a muted word from user preferences.
     */
    async removeMutedWord(mutedWord) {
        await updatePreferences(this, (prefs) => {
            const mutedWordsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isMutedWordsPref(pref) &&
                client_1.AppBskyActorDefs.validateMutedWordsPref(pref).success);
            if (mutedWordsPref && client_1.AppBskyActorDefs.isMutedWordsPref(mutedWordsPref)) {
                for (let i = 0; i < mutedWordsPref.items.length; i++) {
                    const match = matchMutedWord(mutedWordsPref.items[i], mutedWord);
                    if (match) {
                        mutedWordsPref.items.splice(i, 1);
                        break;
                    }
                }
                /**
                 * Migrate any old muted words that don't have an id
                 */
                mutedWordsPref.items = migrateLegacyMutedWordsItems(mutedWordsPref.items);
                return prefs
                    .filter((p) => !client_1.AppBskyActorDefs.isMutedWordsPref(p))
                    .concat([
                    { ...mutedWordsPref, $type: 'app.bsky.actor.defs#mutedWordsPref' },
                ]);
            }
            return prefs;
        });
    }
    /**
     * Convenience method to remove muted words from user preferences
     */
    async removeMutedWords(mutedWords) {
        await Promise.all(mutedWords.map((word) => this.removeMutedWord(word)));
    }
    async hidePost(postUri) {
        await updateHiddenPost(this, postUri, 'hide');
    }
    async unhidePost(postUri) {
        await updateHiddenPost(this, postUri, 'unhide');
    }
    async bskyAppQueueNudges(nudges) {
        await updatePreferences(this, (prefs) => {
            let bskyAppStatePref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isBskyAppStatePref(pref) &&
                client_1.AppBskyActorDefs.validateBskyAppStatePref(pref).success);
            bskyAppStatePref = bskyAppStatePref || {};
            nudges = Array.isArray(nudges) ? nudges : [nudges];
            bskyAppStatePref.queuedNudges = (bskyAppStatePref.queuedNudges || []).concat(nudges);
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isBskyAppStatePref(p))
                .concat([
                {
                    ...bskyAppStatePref,
                    $type: 'app.bsky.actor.defs#bskyAppStatePref',
                },
            ]);
        });
    }
    async bskyAppDismissNudges(nudges) {
        await updatePreferences(this, (prefs) => {
            let bskyAppStatePref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isBskyAppStatePref(pref) &&
                client_1.AppBskyActorDefs.validateBskyAppStatePref(pref).success);
            bskyAppStatePref = bskyAppStatePref || {};
            nudges = Array.isArray(nudges) ? nudges : [nudges];
            bskyAppStatePref.queuedNudges = (bskyAppStatePref.queuedNudges || []).filter((nudge) => !nudges.includes(nudge));
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isBskyAppStatePref(p))
                .concat([
                {
                    ...bskyAppStatePref,
                    $type: 'app.bsky.actor.defs#bskyAppStatePref',
                },
            ]);
        });
    }
    async bskyAppSetActiveProgressGuide(guide) {
        if (guide &&
            !client_1.AppBskyActorDefs.validateBskyAppProgressGuide(guide).success) {
            throw new Error('Invalid progress guide');
        }
        await updatePreferences(this, (prefs) => {
            let bskyAppStatePref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isBskyAppStatePref(pref) &&
                client_1.AppBskyActorDefs.validateBskyAppStatePref(pref).success);
            bskyAppStatePref = bskyAppStatePref || {};
            bskyAppStatePref.activeProgressGuide = guide;
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isBskyAppStatePref(p))
                .concat([
                {
                    ...bskyAppStatePref,
                    $type: 'app.bsky.actor.defs#bskyAppStatePref',
                },
            ]);
        });
    }
}
exports.BskyAgent = BskyAgent;
/**
 * This function updates the preferences of a user and allows for a callback function to be executed
 * before the update.
 * @param cb - cb is a callback function that takes in a single parameter of type
 * AppBskyActorDefs.Preferences and returns either a boolean or void. This callback function is used to
 * update the preferences of the user. The function is called with the current preferences as an
 * argument and if the callback returns false, the preferences are not updated.
 */
async function updatePreferences(agent, cb) {
    try {
        await agent._prefsLock.acquireAsync();
        const res = await agent.app.bsky.actor.getPreferences({});
        const newPrefs = cb(res.data.preferences);
        if (newPrefs === false) {
            return res.data.preferences;
        }
        await agent.app.bsky.actor.putPreferences({
            preferences: newPrefs,
        });
        return newPrefs;
    }
    finally {
        agent._prefsLock.release();
    }
}
/**
 * A helper specifically for updating feed preferences
 */
async function updateFeedPreferences(agent, cb) {
    let res;
    await updatePreferences(agent, (prefs) => {
        let feedsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isSavedFeedsPref(pref) &&
            client_1.AppBskyActorDefs.validateSavedFeedsPref(pref).success);
        if (feedsPref) {
            res = cb(feedsPref.saved, feedsPref.pinned);
            feedsPref.saved = res.saved;
            feedsPref.pinned = res.pinned;
        }
        else {
            res = cb([], []);
            feedsPref = {
                $type: 'app.bsky.actor.defs#savedFeedsPref',
                saved: res.saved,
                pinned: res.pinned,
            };
        }
        return prefs
            .filter((pref) => !client_1.AppBskyActorDefs.isSavedFeedsPref(pref))
            .concat([feedsPref]);
    });
    return res;
}
async function updateSavedFeedsV2Preferences(agent, cb) {
    let maybeMutatedSavedFeeds = [];
    await updatePreferences(agent, (prefs) => {
        let existingV2Pref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isSavedFeedsPrefV2(pref) &&
            client_1.AppBskyActorDefs.validateSavedFeedsPrefV2(pref).success);
        let existingV1Pref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isSavedFeedsPref(pref) &&
            client_1.AppBskyActorDefs.validateSavedFeedsPref(pref).success);
        if (existingV2Pref) {
            maybeMutatedSavedFeeds = cb(existingV2Pref.items);
            existingV2Pref = {
                ...existingV2Pref,
                items: maybeMutatedSavedFeeds,
            };
        }
        else {
            maybeMutatedSavedFeeds = cb([]);
            existingV2Pref = {
                $type: 'app.bsky.actor.defs#savedFeedsPrefV2',
                items: maybeMutatedSavedFeeds,
            };
        }
        // enforce ordering, pinned then saved
        const pinned = existingV2Pref.items.filter((i) => i.pinned);
        const saved = existingV2Pref.items.filter((i) => !i.pinned);
        existingV2Pref.items = pinned.concat(saved);
        let updatedPrefs = prefs
            .filter((pref) => !client_1.AppBskyActorDefs.isSavedFeedsPrefV2(pref))
            .concat(existingV2Pref);
        /*
         * If there's a v2 pref present, it means this account was migrated from v1
         * to v2. During the transition period, we double write v2 prefs back to
         * v1, but NOT the other way around.
         */
        if (existingV1Pref) {
            const { saved, pinned } = existingV1Pref;
            const v2Compat = (0, util_1.savedFeedsToUriArrays)(
            // v1 only supports feeds and lists
            existingV2Pref.items.filter((i) => ['feed', 'list'].includes(i.type)));
            existingV1Pref = {
                ...existingV1Pref,
                saved: Array.from(new Set([...saved, ...v2Compat.saved])),
                pinned: Array.from(new Set([...pinned, ...v2Compat.pinned])),
            };
            updatedPrefs = updatedPrefs
                .filter((pref) => !client_1.AppBskyActorDefs.isSavedFeedsPref(pref))
                .concat(existingV1Pref);
        }
        return updatedPrefs;
    });
    return maybeMutatedSavedFeeds;
}
/**
 * Helper to transform the legacy content preferences.
 */
function adjustLegacyContentLabelPref(pref) {
    let visibility = pref.visibility;
    // adjust legacy values
    if (visibility === 'show') {
        visibility = 'ignore';
    }
    return { ...pref, visibility };
}
/**
 * Re-maps legacy labels to new labels on READ. Does not save these changes to
 * the user's preferences.
 */
function remapLegacyLabels(labels) {
    const _labels = { ...labels };
    const legacyToNewMap = {
        gore: 'graphic-media',
        nsfw: 'porn',
        suggestive: 'sexual',
    };
    for (const labelName in _labels) {
        const newLabelName = legacyToNewMap[labelName];
        if (newLabelName) {
            _labels[newLabelName] = _labels[labelName];
        }
    }
    return _labels;
}
/**
 * A helper to get the currently enabled labelers from the full preferences array
 */
function prefsArrayToLabelerDids(prefs) {
    const labelersPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isLabelersPref(pref) &&
        client_1.AppBskyActorDefs.validateLabelersPref(pref).success);
    let dids = [];
    if (labelersPref) {
        dids = labelersPref.labelers.map((labeler) => labeler.did);
    }
    return dids;
}
async function updateHiddenPost(agent, postUri, action) {
    await updatePreferences(agent, (prefs) => {
        let pref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isHiddenPostsPref(pref) &&
            client_1.AppBskyActorDefs.validateHiddenPostsPref(pref).success);
        if (pref && client_1.AppBskyActorDefs.isHiddenPostsPref(pref)) {
            pref.items =
                action === 'hide'
                    ? Array.from(new Set([...pref.items, postUri]))
                    : pref.items.filter((uri) => uri !== postUri);
        }
        else {
            if (action === 'hide') {
                pref = {
                    $type: 'app.bsky.actor.defs#hiddenPostsPref',
                    items: [postUri],
                };
            }
        }
        return prefs
            .filter((p) => !client_1.AppBskyActorDefs.isInterestsPref(p))
            .concat([{ ...pref, $type: 'app.bsky.actor.defs#hiddenPostsPref' }]);
    });
}
function isBskyPrefs(v) {
    return (v &&
        typeof v === 'object' &&
        'moderationPrefs' in v &&
        isModPrefs(v.moderationPrefs));
}
function isModPrefs(v) {
    return v && typeof v === 'object' && 'labelers' in v;
}
function migrateLegacyMutedWordsItems(items) {
    return items.map((item) => ({
        ...item,
        id: item.id || common_web_1.TID.nextStr(),
    }));
}
function matchMutedWord(existingWord, newWord) {
    // id is undefined in legacy implementation
    const existingId = existingWord.id;
    // prefer matching based on id
    const matchById = existingId && existingId === newWord.id;
    // handle legacy case where id is not set
    const legacyMatchByValue = !existingId && existingWord.value === newWord.value;
    return matchById || legacyMatchByValue;
}
//# sourceMappingURL=bsky-agent.js.map